# 算法 & 数据结构

常用数据结构

* 数组
* 栈
* 队列
* 链表
* 树

## 一、数组

数组的创建

```js
// 一维数组
const arr1 = new Array(7);
const arr2 = new Array(7);
const arr3 = (new Array(7)).fill(1)

// 数组的引用
const arr4 =(new Array(7)).fill([])

const len = arr1.length
for (let i = 0; i < len; i++) {
  // 将数组的每一个坑位初始化为数组
  arr[i] = []
}
```

## 二、栈和队列

在 JavaScript 中，栈和队列的实现一般都要依赖于数组，大家完全可以把栈和队列都看作是“特别的数组”。

> 数组中增加元素的三种方法 => push、unshift、splice

> 数组中删除元素的三种方法 => pop、shift、splice

### 1、栈（Stack）=> 只用 pop 和 push 完成增删的“数组”

栈是一种后进先出(LIFO，Last In First Out)的数据结构。

* 只允许从尾部添加元素
* 只允许从尾部取出元素

### 2、队列（Queue）——只用 push 和 shift 完成增删的“数组”

队列是一种先进先出（FIFO，First In First Out）的数据结构。

## 三、链表

链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是离散的。

> 数组在内存中最为关键的一个特征，就是它一般是对应一段位于自己上界和下界之间的、一段连续的内存空间。元素与元素之间，紧紧相连。

> 链表中的结点，则允许散落在内存空间的各个角落里。一个内容为1->2->3->4->5的链表。

在链表中，每一个结点的结构都包括了两部分的内容：`数据域` 和 `指针域`。JS 中的链表，是以嵌套的对象的形式来实现的：

```js
{
  // 数据域
  val: 1,
  // 指针域，指向下一个结点
  next: {
    val:2,
    next: ...
  }
}   
```

要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置。

### 链表结点的创建

创建链表结点，咱们需要一个构造函数：

```js
function ListNode(val) {
  this.val = val;
  this.next = null;
}
```

在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：

```js
const node = new ListNode(1)  
node.next = new ListNode(2)
```

### 链表元素的添加

结合前面的学习，我们已经知道，链表的结点间关系是通过 next 指针来维系的。因此，链表元素的添加和删除操作，本质上都是在围绕 next 指针做文章。

> 如何在两个结点间插入一个结点？

注意，由于链表有时会有头结点，这时即便你是往链表头部增加结点，其本质也是`在头结点和第一个结点之间插入一个新结点`。所以说，任意两结点间插入一个新结点这种类型的增加操作，将会是链表基础中的一个关键考点。

要想完成这个动作，我们需要变更的是前驱结点和目标结点的 next 指针指向

```js
// 如果目标结点本来不存在，那么记得手动创建
const node3 = new ListNode(3)     
// 把node3的 next 指针指向 node2（即 node1.next）
node3.next = node1.next
// 把node1的 next 指针指向 node3
node1.next = node3
```

### 链表元素的删除

链表元素的删除也是非常高频的操作。延续我们前面的思路，仍然把重心放在对 next 指针的调整上。

```js
node1.next = next3.next
```

在涉及链表删除操作的题目中，重点不是定位目标结点，而是定位目标结点的前驱结点。做题时，完全可以只使用一个指针（引用），这个指针用来定位目标结点的前驱结点。比如说咱们这个题里，其实只要能拿到 node1 就行了：

```js
// 利用 node1 可以定位到 node3
const target = node1.next  
node1.next = target.next
```

### 链表和数组的辨析

在大多数的计算机语言中，数组都对应着一段连续的内存。如果我们想要在任意位置删除一个元素，那么该位置往后的所有元素，都需要往前挪一个位置；相应地，如果要在任意位置新增一个元素，那么该位置往后的所有元素也都要往后挪一个位置。

**我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)。**

但 JS 中不一定是。

JS比较特别。如果我们在一个数组中只定义了一种类型的元素，比如：

```js
const arr = [1,2,3,4]
```

它是一个纯数字数组，那么对应的确实是连续内存。

但如果我们定义了不同类型的元素：

```js
const arr = ['haha', 1, {a:1}]
```

它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用`哈希映射分配内存空间，是由对象链表来实现的`。

说起来有点绕口，但大家谨记“JS 数组未必是真正的数组”即可。

何谓“真正的数组”？在各大教材（包括百科词条）对数组的定义中，都有一个“存储在连续的内存空间里”这样的必要条件。因此在本文中，我们描述的“数组”就是符合这个定义的数组。面试时，若考到数组和链表的辨析，大家也沿着这个思路往下说，是没有问题的。如果能够说出 JS 数组和常规数组的不同，那就是锦上添花了。

相对于数组来说，链表有一个明显的优点，**就是添加和删除元素都不需要挪动多余的元素**。

### 高效的增删操作

在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 **因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。**

### 麻烦的访问操作

但是链表也有一个弊端：当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，我需要这样做：

```js
// 记录目标结点的位置
const index = 10  
// 设一个游标指向链表第一个结点，从第一个结点开始遍历
let node = head  
// 反复遍历到第10个结点为止
for(let i = 0; i < index && node; i++) {
  node = node.next
}
```

随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。

但在数组中，我们直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别(O(1))：

```js
arr[9]
```

### 总结

结合上述分析，我们不难得出这样的结论：链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。这个特性需要大家牢记，可能会作为数据结构选型的依据来单独考察。

## 四、树

数据结构中的树，首先是对现实世界中树的一层简化：把树根抽象为“根结点”，树枝抽象为“边”，树枝的两个端点抽象为“结点”，树叶抽象为“叶子结点”。

* 树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
* 结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
* “度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。
* “叶子结点”：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。

### 二叉树结构

二叉树是指满足以下要求的树：

* 它可以没有根结点，作为一棵空树存在
* 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

注意，二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。

### 二叉树的编码实现

在 JS 中，二叉树使用对象来定义。它的结构分为三块：

* 数据域
* 左侧子结点（左子树根结点）的引用
* 右侧子结点（右子树根结点）的引用

在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：

```js
// 二叉树结点的构造函数
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}
```

当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：

```js
const node  = new TreeNode(1)
```

### 二叉树遍历

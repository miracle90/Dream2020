# 特殊的二叉树——堆结构及其在排序中的应用

本节内容不要求所有同学掌握——如果你在阅读的过程中，觉得理解起来非常吃力，笔者建议你暂时跳过这一节，优先完成全盘的知识点扫盲后再回来看。

为什么这样说？这里面有两个原因：

1. 根据笔者长期奋战算法面试一线的经验，能用堆结构解决的问题，基本上也都能用普通排序来解决。
2. 即便是后端工程师或者算法工程师，能够在面试现场手写堆结构的人也寥寥无几。这倒不是因为他们不够专业，而是因为他们基本都非常熟悉一门叫做 JAVA 的语言——JAVA大法好，它在底层封装了一个叫做 `priorty_queue` 的数据结构，这个数据结构把堆的构建、插入、删除等操作全部做掉了。所以说这帮人非常喜欢做堆/优先队列相关的题目，调几个API就完事儿了。

那么为什么还要讲堆结构，堆结构在我们整个知识体系里的定位应该怎么去把握，这里有两件事情希望大家能明白：

1. 几乎每一本正经的计算机专业数据结构教材，都会介绍堆结构。小册本身虽然是面向面试的，但笔者更希望能借这个机会，帮助一部分没有机会接受科班教育的前端同行补齐自身的知识短板。

2. 笔者个人在素材调研期间经历过的 N 次涉及算法的前端面试中，有1次真的考到了需要用堆结构解决的问题（这道题在下面的讲解中也会出现）。当时笔者还不知道堆的玩法，直接用JS的排序API做出来了。事后和面试官聊天的时候，突然被他要求用堆结构再做一遍。最后虽然在没写出来的情况下拿到了offer，但事后想起来，还是非常后怕——没有人能预知自己下一次遇到的面试官到底是什么脾气，我们只能尽自己所能地去做万全的准备。

## 前置知识：完全二叉树

完全二叉树是指同时满足下面两个条件的二叉树：

1. 从第一层到倒数第二层，每一层都是满的，也就是说每一层的结点数都达到了当前层所能达到的最大值
2. 最后一层的结点是从左到右连续排列的，不存在跳跃排列的情况（也就是说这一层的所有结点都集中排列在最左边）。

注意，完全二叉树中有着这样的索引规律：假如我们从左到右、从上到下依次对完全二叉树中的结点从0开始进行编码：

那么对于索引为 n 的结点来说：

1. 索引 (n-1)/2 的结点是它的父结点
2. 索引 2*n+1 的结点是它的左孩子结点
3. 索引 2*n+2 的结点是它的右孩子结点

## 什么是堆

堆是**完全二叉树**的一种特例。根据约束规则的不同，堆又分为两种：

1. 大顶堆
2. 小顶堆

> 如果对一棵完全二叉树来说，它每个结点的结点值都不小于其左右孩子的结点值，这样的完全二叉树就叫做“大顶堆”：

> 若树中每个结点值都不大于其左右孩子的结点值，这样的完全二叉树就叫做“小顶堆”

## 堆的基本操作：以大顶堆为例

大顶堆和小顶堆除了约束条件中的大小关系规则完全相反以外，其它方面都保持高度一致。现在我们以大顶堆为例，一起来看看堆结构有哪些玩法。

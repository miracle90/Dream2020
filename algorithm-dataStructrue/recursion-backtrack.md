# 递归与 场景化解读：递归与回溯思想在真题中的应用

## 关键套路初相见：全排列问题

> 题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。

#### 示例

```
输入: [1,2,3]

输出: [
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

#### 思路分析

“全排列”是高中数学里的一个概念，这里先带大家复习一下： 

> 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。

我们把三个坑的情况统筹起来，那么全排列就一共有 3x2x1=6  种可能。可惜这道题问的不是全排列的可能性有多少种，而是要求你把每一种可能性都穷举出来。这其实有点类似于我们上一节玩迷宫游戏的时候，游戏规则不仅要求你回答出迷宫的通关方法有几种，还要求你列举出每一条路的路径。列举“路径”，我们首先要找到“坐标”。在这道题里，“坐标”就是每一个坑里可能填进的数字。

#### 编码实现

```js
/**
 * 排列问题
 * @param {number[]} nums
 * @return {number[][]}
 */
const permute = function (nums) {
  const len = nums.length
  const res = []
  const current = []
  const used = {}
  // 从索引为 0 的坑位（也就是第一个坑位）开始 dfs
  dfs(0)
  // 定义 dfs 函数，入参是坑位的索引（从 0 计数）
  function dfs(index) {
    // 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回
    if (index === len) {
      res.push([...current])
      return
    }
    // 检查手里剩下的数字有哪些
    for (let i = 0; i < len; i++) {
      // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”
      if (!used[nums[i]]) {
        // 给 nums[i] 打个“已用过”的标
        used[nums[i]] = 1
        // 将nums[i]推入当前排列
        current.push(nums[i])
        // 基于这个排列继续往下一个坑走去
        dfs(index + 1)
        // nums[i]让出当前坑位
        current.pop()
        // 下掉“已用过”标识
        used[nums[i]] = 0
      }
    }
  }
  return res
};
console.log(permute([1, 2, 3]))
```

上面这坨代码里，有两个点需要大家格外注意，它们将会成为我们以后做类似题目的关键技巧：   

* Map 结构 visited  的使用：填坑时，每用到一个数字，我们都要给这个数字打上“已用过”的标——避免它被使用第二次；数字让出坑位时，对应的排列和 visited  状态也需要被及时地更新掉。
* 当走到递归边界时，一个完整的排列也到手了。将这个完整排列推入结果数组时，我们用了  res.push(curr.slice()) 而不是简单的 res.push(curr) 。为什么这样做？因为全局只有一个唯一的 curr ， curr 的值会随着 dfs 的进行而不断被更新。 slice 方法的作用是帮助我们拷贝出一个不影响curr正本的副本，以防直接修改到curr的引用。

## 组合问题：变化的“坑位”，不变的“套路”

> 题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

#### 示例

```
示例: 输入: nums = [1,2,3]

输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

#### 思路分析

见到这道题，大家第一反应会是什么？吸取了上一道题的经验，这道题我们应该想到的是：穷举出现了，大概率会用到 DFS。

只要用到 DFS，就不得不想到树形思维方式，进而不得不思考递归式和递归边界的问题。在这个思考的过程中，最重要的一环就是对“坑位”的定位和分析。
从上一道题中，我们不难看出，“坑位”对应的就是树形逻辑中树的某一层，“坑位数”往往意味着递归边界的限制条件。  

找“坑位”的思路也是具有规律的：“坑位”往往是那些不会变化的东西。在上一道题中，排列的顺序是变化的，而每个排列中数字的个数却是不变的，因此数字的个数就对应“坑位”的个数；在这道题中，每个组合中数字的个数是不确定的，不变的东西变成了可以参与组合的数字，变化的东西则是每个数字在组合中的存在性。因此我们的思路可以调整为，从每一个数字入手，讨论它出现或者不出现的情况。 

我们分析一下这个过程中的递归式与递归边界：  

* 递归式：检查手里剩下的数字有哪些（有没有发现和上一道题的递归式是一样的，因为两道题都强调了数字不能重复使用），选取其中一个填进当前的坑里、或者干脆把这个坑空出来（这里就体现出了和上一道题的区别，这道题强调的是存在性而非顺序）。  
* 递归边界：组合里数字个数的最大值。拿示例来说，只给了 3 个数，因此组合里数字最多也只有 3 个，超过 3 个则视为触碰递归边界。

#### 编码实现

```js
/**
 * 组合问题
 * @param {number[]} nums
 * @return {number[][]}
 */
const subsets = function (nums) {
  const len = nums.length
  const res = []
  // 初始化组合数组
  const item = []
  dfs(0)
  // 定义 dfs 函数，入参是 nums 中的数字索引
  function dfs(index) {
    // 每次进入，都意味着组合内容更新了一次，故直接推入结果数组
    res.push([...item])
    // 从当前数字的索引开始，遍历 nums
    for (let i = index; i < len; i++) {
      // 这是当前数字存在于组合中的情况
      item.push(nums[i])
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i + 1)
      // 这是当前数字不存在与组合中的情况
      item.pop()
    }
  }
  return res
};
console.log(subsets([1, 2, 3]))
```

#### 编码复盘

这道题和上一道题的基本思路高度一致，但是在实现上有些差别。对初学者来说，即便是非常微小的变化也有可能引起困惑。因此，我在这里针对编码部分变化的内容作进一步讲解： 

* 递归式的变化：在上一道题中，我们检查一个数字是否可用的依据是它是否已被纳入当前排列（ visited 值是否为 1），而这道题中，并不存在一个类似 visited 一样的标记对象。取而代之的，是每次直接以 index 作为了索引起点。这是因为，在排列场景下，一个元素可能出现在任何坑位里；而在组合场景下，坑位的选择逻辑发生了变化，坑位和元素是一一对应的。因此讨论完一个坑位的取舍后，一个元素的取舍也相应地讨论完毕了，直接跳过这个元素的索引往下走即可。
* 递归边界的变化：这道题中，并没有显式的 return 语句来标示递归边界的存在。这个边界的判定被 for 语句偷偷地做掉了： for 语句会遍历所有的数字，当数字遍历完全时，也就意味着递归走到了尽头。


## 限定组合问题：及时回溯，即为“剪枝”  

> 题目描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

#### 示例

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

#### 思路分析

这是一道复杂化的组合问题，它追加了一个限定条件——只返回 n 个数中 k 个数的组合。在普通的组合问题中，树形逻辑是这样的：  

#### 编码实现

```js
/**
 * 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
const combine = function (n, k) {
  const res = []
  const item = []
  dfs(1)
  function dfs(index) {
    if (item.length === k) {
      return res.push([...item])
    }
    for (let i = index; i <= n; i++) {
      item.push(i)
      dfs(i + 1)
      item.pop()
    }
  }
  return res
};
console.log(combine(4, 2))
```

注意这道题中虽然没有直接给出一个 nums 数组，而是直接约定了数字的范围为 1-n ，但其本质仍然是一个数字集合，我们像上面这样稍微调整下取值方式即可。

## 概念复盘：何为“回溯”？  

现在，或许你还暂时不知道何为“回溯算法”，但你其实已经实打实地在真题中对它有了具体的实践。基于这些实践，我们反过来理解一下回溯的概念：

```
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。
```

## 递归与回溯问题——解题模板总结

```js
function xxx(入参) {
  前期的变量定义、缓存等准备工作 
  
  // 定义路径栈
  const path = []
  
  // 进入 dfs
  dfs(起点) 
  
  // 定义 dfs
  dfs(递归参数) {
    if(到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return   
    }
    
    // 注意这里也可能不是 for，视题意决定
    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}
```
